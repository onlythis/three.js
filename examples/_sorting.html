<!DOCTYPE html>
<html lang="en">
<head>
	<title>Sortin</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0,
	maximum-scale=1.0">
	<style>
	body {
		color: #cccccc;
		font-family:Monospace;
		font-size:13px;
		text-align:center;
		background-color: #050505;
		margin: 0px;
		overflow: hidden;
	}
	#info {
		position: absolute;
		top: 0px; width: 100%;
		padding: 5px;
	}
	</style>
</head>
<body>
	<div id="info">Sort</div>
	<script src="js/libs/dat.gui.min.js"></script>
	<script src="../build/three.js"></script>
	<script src="js/controls/OrbitControls.js"></script>
	<script src="js/libs/stats.min.js"></script>
	<script>
	'use strict';

	var scene, camera, renderer, controls, group, container, stats;
	function init() {
		container = document.createElement( 'div' );
		document.body.appendChild( container );
		scene = new THREE.Scene();
		camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.3, 1000);
		camera.position.z = 30;
		camera.position.y = 0;
		camera.position.x = 0;
		camera.lookAt(scene.position);

		renderer = new THREE.WebGLRenderer();
		renderer.setPixelRatio(window.devicePixelRatio);
		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.setClearColor(0x0E2255);
		renderer.shadowMap.enabled = true;
		container.appendChild(renderer.domElement);
		stats = new Stats();
		container.appendChild(stats.dom);

		//click to move screen, zoom in and out
		controls = new THREE.OrbitControls(camera, renderer.domElement);

		const ambientLight = new THREE.AmbientLight();
		scene.add(ambientLight);

		const light = new THREE.DirectionalLight();
		light.position.set(200, 100, 200);
		light.castShadow = true;
		light.shadow.camera.left = -100;
		light.shadow.camera.right = 100;
		light.shadow.camera.top = 100;
		light.shadow.camera.bottom = -100;
		scene.add(light);

		group = new THREE.Group();
		scene.add( group );
		initCircle(sphere_count);
		initGUI();
		document.addEventListener( 'mousemove', onDocumentMouseMove, false );
		document.addEventListener( 'mousedown', onDocumentMouseDown, false );

		document.body.appendChild(renderer.domElement);
		window.addEventListener('resize', onResize);
		console.log(scene);
	}

	function onResize() {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize(window.innerWidth, window.innerHeight);
	}

	var sphere_size = new THREE.SphereGeometry(.25, 16, 16);
	function drawElem(x,y,z, hue) {
		var mat = new THREE.MeshPhongMaterial({
			color: new THREE.Color(),
			flatShading: THREE.FlatShading,
			transparent: true,
			opacity: 1
		});
		mat.color.setHSL(hue/360, 1, 0.5);
		const obj = new THREE.Mesh(sphere_size, mat);
		obj.castShadow = true;
		obj.receiveShadow = true;
		obj.position.set(x,y,z);
		//obj.rotateY(rot);
		//scene.children[2].add(obj);
		group.add(obj);
		return obj;
	}

	function precisionRound(number, precision) {
		var factor = Math.pow(10, precision);
		return Math.round(number * factor) / factor;
	}

	// Creates sphere obj's in a circle starting from east.
	var spheres = [];
	var sphere_count = 128;
	var sphere_pos = [];
	function initCircle(count){
		sphere_count = count;
		spheres = [];
		sphere_pos = [];
		for(var x = 0; x < count; x++) {
			var x_pos = Math.cos(x / count * 2 * Math.PI) * 10;
			var y_pos = Math.sin(x / count * 2 * Math.PI) * 10;
			spheres.push( drawElem( x_pos , y_pos , 0, x * 360 / count));
			sphere_pos.push([]);
			sphere_pos[x].push(x_pos);
			sphere_pos[x].push(y_pos);
		}
	}

	// given obj and index to check. returns true if obj is in position of index.
	function checkPos(obj, index) {
		// sphere_pos[index][x(0) or y(1)]
		if(precisionRound(obj.position.x, 5) == precisionRound(sphere_pos[index][0], 5) &&
			 precisionRound(obj.position.y, 5) == precisionRound(sphere_pos[index][1], 5)) {
			return true;
		}
		return false;
	}

	function sortCheck() {
		var count = 0;
		for(var x = 0; x < spheres.length; x++){
			if(checkPos(spheres[x], x)) { count++; }
		}
		console.log("spheres in initial index: " + count);
	}

	var effectController = {
		reset: resetCircle,
		stop: stopAnim,
		checkSorted: sortCheck,
		shuffle: shuffleSome,
		shuffleSize: 5,
		shuffleTimeInterval: .5,
		shuffleSpeed: 50,
		sphereCount: 128
	};
	function resetCircle(){
		scene.remove(group);
		group = new THREE.Group();
		scene.add( group );
		initCircle(sphere_count);
	}
	function initGUI() {
		var gui = new dat.GUI();
		gui.add( effectController, "reset" );
		gui.add( effectController, "stop" );
		gui.add( effectController, "checkSorted");
		gui.add( effectController, "shuffle");
		gui.add( effectController, "shuffleSize", 1, 40, 1 ).onChange( function( value ) { shuffle_size = value; } );
		gui.add( effectController, "shuffleTimeInterval", 0, 1, .02 ).onChange( function( value ) { shuffle_time_interval = value; } );
		gui.add( effectController, "shuffleSpeed", 1, 100, 1 ).onChange( function( value ) { swapping_speed = value; } );
		gui.add( effectController, "sphereCount", 0, 128, 1 ).onChange( function( value ) {
			scene.remove(group);
			group = new THREE.Group();
			scene.add( group );
			initCircle(value);
		});
	}

	var mouse = new THREE.Vector2();
	var raycaster = new THREE.Raycaster();
	var intersected;
	function onDocumentMouseMove( event ) {
		event.preventDefault();
		mouse.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );
		raycaster.setFromCamera( mouse, camera );
		//scene.children[2].children = spheres
		//highlights spheres white while mouse is over them ( change to emissive )
		var intersects = raycaster.intersectObjects( scene.children[2].children );
		//if mouse intersects a sphere
		if ( intersects.length > 0 ) {
			//if mouse is still over same object skip
			if ( intersected != intersects[0].object){
				//if mouse was on an obj and moves to another without becoming null
				if(intersected && intersected != selected){
					intersected.material.emissive.setHex( 0x000000 );
				}
				intersected = intersects[ 0 ].object;
				intersected.material.emissive.setHex( 0xaaaaaa );
			}

		} else {
			//if mouse just moved off a sphere
			//intersected gets reassigned to selected because the mouse moved in the same obj
			if ( intersected && intersected != selected) {
				intersected.material.emissive.setHex( 0x000000 );
			}
			intersected = null;
		}
	}

	var selected;
	function onDocumentMouseDown( event ) {
		event.preventDefault();
		// click two spheres to swap them
		//intersected constantly updates, swap when 2nd sphere has been selected
		if( intersected ) {
			if( selected ) {
				//first clicked is selected
				swap(selected, intersected);
			} else {
				//stays emissive while selected as first sphere to swap
				selected = intersected;
				selected.material.emissive.setHex( 0xaaaaaa );
			}
		}
		//console.log(selected);
	}

	var motion_counter = [];
	var swapping_obj = [];
	var swapping_speed = 50;
	var atan1 = [], atan2 = [], radius = [], x_avg = [], y_avg = [];
	var pi = Math.PI;

	// glitches when swapping an obj that is already moving. glitch happens when the swap before finishes moving.
	// looks like they briefly swap positions(only visible sometimes). Works out in the end though.

	function swap(obj1, obj2) {
		//console.log(obj1.position.x, obj1.position.y, obj2.position.x, obj2.position.y);
		//find middle of obj1, obj2
		x_avg.push((obj1.position.x + obj2.position.x) / 2);
		y_avg.push((obj1.position.y + obj2.position.y) / 2);

		//unemissive and reassign selected and intersected
		if(selected){
			selected.material.emissive.setHex( 0x000000 );
			selected = null;
		}
		if(intersected){
			intersected.material.emissive.setHex( 0x000000 );
			intersected = null;
		}

		// swapping_obj is 2d array. pairs of swapping objs.
		swapping_obj.push([]);
		swapping_obj[swapping_obj.length - 1].push(obj1);
		swapping_obj[swapping_obj.length - 1].push(obj2);

		//finding radians(position on circle created by the two objs and their center) of objs with regards to the avg_pos(middle)
		//swap_obj is avg pos of the pair of swapping objs
		var swap_obj1x, swap_obj1y, swap_obj2x, swap_obj2y;
		swap_obj1x = obj1.position.x - x_avg[x_avg.length - 1];
		swap_obj1y = obj1.position.y - y_avg[y_avg.length - 1];
		swap_obj2x = obj2.position.x - x_avg[x_avg.length - 1];
		swap_obj2y = obj2.position.y - y_avg[y_avg.length - 1];
		// Math.atan2 returns the radians of two coordinates on a plane. (0,0) is center of circle. Takes in y first, x second (y,x)
		// cosine of atan2 gives x coordinate
		atan1.push(Math.atan2(swap_obj1y, swap_obj1x));
		atan2.push(Math.atan2(swap_obj2y, swap_obj2x));
		//distance formula
		radius.push(Math.sqrt(Math.pow(obj1.position.x - obj2.position.x , 2) + Math.pow(obj1.position.y - obj2.position.y , 2)) / 2);
		//counter needed to ensure proper distance and time of rotation
		motion_counter.push(0);
	}

	//how is it able to have same obj in two swaps simultaneously?  1 obj is assigned to mutliple elements in swapping_obj array.

	var shuffle_size = 5;
	var shuffle_stack = [];
	function shuffleSome() {
		//var curr_time = Date.now() * 0.001;
		if(shuffle_size * 2 > sphere_count) { console.log("shuffle size to large"); return; }
		var elems = [];
		for(var x=0; x<shuffle_size; x++){
			var first_rand = Math.round(Math.random() * (sphere_count - 1));
			var second_rand = Math.round(Math.random() * (sphere_count - 1));
			// don't want to shuffle same sphere twice
			while(elems.indexOf(first_rand) != -1){
				first_rand = Math.round(Math.random() * (sphere_count - 1));
			}
			elems.push(first_rand);
			while(elems.indexOf(second_rand) != -1){
				second_rand = Math.round(Math.random() * (sphere_count - 1));
			}
			elems.push(second_rand);
			shuffle_stack.push( spheres[first_rand]);
			shuffle_stack.push(spheres[second_rand]);
		}
	}

	var next_time = 0;
	var start_anim;
	var shuffle_time_interval = .5;
	function animate() {
		// swaps spheres at set time intervals
		if (shuffle_stack.length > 0) {
			var time = Date.now() * 0.001;
			while(time >= next_time && shuffle_stack.length > 0) {
				swap(shuffle_stack.shift(), shuffle_stack.shift());
				next_time = time + shuffle_time_interval;
			}
		}

		// for each obj currently moving
		for(var x = 0; x < swapping_obj.length; x++) {
			//obj starts moving from its current position.
			motion_counter[x] += .001;
			swapping_obj[x][0].position.x = Math.cos(atan1[x] + motion_counter[x] * swapping_speed) * radius[x] + x_avg[x];
			swapping_obj[x][0].position.y = Math.sin(atan1[x] + motion_counter[x] * swapping_speed) * radius[x] + y_avg[x];
			swapping_obj[x][1].position.x = Math.cos(atan2[x] + motion_counter[x] * swapping_speed) * radius[x] + x_avg[x];
			swapping_obj[x][1].position.y = Math.sin(atan2[x] + motion_counter[x] * swapping_speed) * radius[x] + y_avg[x];
			//motion_counter * swapping_speed will equal pi when each obj in a pair has rotated exactly 180 degrees
			if( motion_counter[x] * swapping_speed >= pi ) {
				swapping_obj[x][0].position.x = Math.cos(atan1[x] + pi) * radius[x] + x_avg[x];
				swapping_obj[x][0].position.y = Math.sin(atan1[x] + pi) * radius[x] + y_avg[x];
				swapping_obj[x][1].position.x = Math.cos(atan2[x] + pi) * radius[x] + x_avg[x];
				swapping_obj[x][1].position.y = Math.sin(atan2[x] + pi) * radius[x] + y_avg[x];
				//console.log(swapping_obj[x][0].position.x, swapping_obj[x][0].position.y, swapping_obj[x][1].position.x, swapping_obj[x][1].position.y)
				//shift() - removes the first element in an array
				swapping_obj.shift(); motion_counter.shift(); atan1.shift(); atan2.shift(); radius.shift(); x_avg.shift(); y_avg.shift();
				//if two swapping_obj's reach pi at same time, shift() will cause skipping. so need x--
				//why doesn't this cause index out of bounds? for loop condition(x < swapping_obj.length) re-evaluates every loop.
				x--;
			}
		}
		start_anim = requestAnimationFrame(animate);
		stats.update();
		renderer.render(scene, camera);
	}

	function stopAnim() {
		cancelAnimationFrame( start_anim );
	}

	init();
	animate();

	/* calculate entropy?
	shuffle in timed intervals

	*/
	</script>
</body>
</html>
